<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="行走路上,记录风景~">
<meta property="og:type" content="website">
<meta property="og:title" content="pp锅的小站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="pp锅的小站">
<meta property="og:description" content="行走路上,记录风景~">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="pp锅的小站">
<meta name="twitter:description" content="行走路上,记录风景~">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> pp锅的小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">pp锅的小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">初入iOS开发路上的小菜鸟~</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/iOS处理图片大小总结/" itemprop="url">
                  iOS处理图片大小总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T19:27:45+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/iOS处理图片大小总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/iOS处理图片大小总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS中图片相关的内容非常多,iOS中的图片相关的API也非常多,从UIKit中的UIImage,到CoreGraphic中CGImage,CoreImage中的CIImage.</p>
<p>通常情况下使用UIImage来缩放图片大小,在UIImage有<code>contentMode</code>属性,会有多个枚举属性<code>.ScaleAspectFit</code>,<code>.ScaleAspectFill</code>,通过赖进行</p>
<h3 id="使图片缩放改变大小"><a href="#使图片缩放改变大小" class="headerlink" title="使图片缩放改变大小"></a>使图片缩放改变大小</h3><p>在进行图片的缩放的大小时,首先需要了解到缩放的目标大小.</p>
<h4 id="直接通过缩放因子改变大小"><a href="#直接通过缩放因子改变大小" class="headerlink" title="直接通过缩放因子改变大小"></a>直接通过缩放因子改变大小</h4><p>最简单的方式就是使用常量factor,去乘以图像的原来大小.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let size = <span class="built_in">CGSize</span>(width: image.size.width/<span class="number">2</span>, height: image.size.height/<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>或者直接使用<code>CGAffineTransform</code>改变transform</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let size = <span class="built_in">CGSizeApplyAffineTransform</span>(image.size, <span class="built_in">CGAffineTransformScale</span>(<span class="number">0.5</span>,<span class="number">0.5</span>))</div></pre></td></tr></table></figure>
<h4 id="不改变Aspect-Ratio的缩放"><a href="#不改变Aspect-Ratio的缩放" class="headerlink" title="不改变Aspect Ratio的缩放"></a>不改变Aspect Ratio的缩放</h4><p>如果要将一个图片放到一个rect中,而不改变它原始的aspect ratio.可以使用<code>AVFoundation</code>的<code>AVMakeRectWithAspectRatioInsideRect</code>方法.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import <span class="built_in">AVFoundation</span></div><div class="line">let rect = <span class="built_in">AVMakeRectWithAspectRatioInsideRect</span>(image.size, imageView.bounds)</div></pre></td></tr></table></figure>
<hr>
<h3 id="改变图片大小的方法汇总"><a href="#改变图片大小的方法汇总" class="headerlink" title="改变图片大小的方法汇总"></a>改变图片大小的方法汇总</h3><p>有多种方法可以改变图片的大小,每种方法的性能不同.</p>
<h4 id="UIGraphicsBeginImageContextWithOptions和UIImage-drawInRect"><a href="#UIGraphicsBeginImageContextWithOptions和UIImage-drawInRect" class="headerlink" title="UIGraphicsBeginImageContextWithOptions和UIImage -drawInRect:"></a><code>UIGraphicsBeginImageContextWithOptions</code>和<code>UIImage -drawInRect:</code></h4><p>通常最高阶的API是UIKit,使用UIImage然后使用Graphic Context实时绘出一个大小不同的图片.可以使用<code>UIGraphicsBeginImageContextWithOptions</code>和<code>UIGraphicsGetImageFromCurrentImageContext</code>获取缩略图.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let image = <span class="built_in">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.URL.absoluteString!)</div><div class="line"></div><div class="line">let size = <span class="built_in">CGSizeApplyAffineTransform</span>(image.size, <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))</div><div class="line">let hasAlpha = <span class="literal">false</span></div><div class="line">let scale: <span class="built_in">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></div><div class="line"></div><div class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</div><div class="line">image.drawInRect(<span class="built_in">CGRect</span>(origin: <span class="built_in">CGPointZero</span>, size: size))</div><div class="line"></div><div class="line">let scaledImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line"><span class="built_in">UIGraphicsEndImageContext</span>()</div></pre></td></tr></table></figure>
<p><code>UIGraphicsBeginImageContextWithOptions()</code>会创建一个渲染context,然后使用原来的图片draw.</p>
<ul>
<li>第一个参数<code>size</code>就是缩小以后的图片的大小.</li>
<li>第二个参数<code>isOpaque</code>,用来描述图片的alpha通道是否渲染.设置为<code>false</code>表示完全不透明</li>
<li>第三个参数<code>scale</code>,就是dispaly scale factor.如果设置成<code>0.0</code>那么就是main screen使用的(retina是2.0,iphone6p是3.0)</li>
</ul>
<h4 id="CGBitmapContextCreate和CGContextDrawImage"><a href="#CGBitmapContextCreate和CGContextDrawImage" class="headerlink" title="CGBitmapContextCreate和CGContextDrawImage"></a><code>CGBitmapContextCreate</code>和<code>CGContextDrawImage</code></h4><p>使用的Core Graphic/Quartz 2D使用的是低阶API,可以使用CGImage,使用<code>CGBitmapContextCreate()</code>和<code>CGBitmapContextCreateImage()</code>获取缩略图.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let cgImage = <span class="built_in">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.URL.absoluteString!).CGImage</div><div class="line"></div><div class="line">let width = <span class="built_in">CGImageGetWidth</span>(cgImage) / <span class="number">2</span></div><div class="line">let height = <span class="built_in">CGImageGetHeight</span>(cgImage) / <span class="number">2</span></div><div class="line">let bitsPerComponent = <span class="built_in">CGImageGetBitsPerComponent</span>(cgImage)</div><div class="line">let bytesPerRow = <span class="built_in">CGImageGetBytesPerRow</span>(cgImage)</div><div class="line">let colorSpace = <span class="built_in">CGImageGetColorSpace</span>(cgImage)</div><div class="line">let bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(cgImage)</div><div class="line">let context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo.rawValue)</div><div class="line"></div><div class="line"><span class="built_in">CGContextSetInterpolationQuality</span>(context, kCGInterpolationHigh)</div><div class="line"><span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRect</span>(origin: <span class="built_in">CGPointZero</span>, size: <span class="built_in">CGSize</span>(width: <span class="built_in">CGFloat</span>(width), height: <span class="built_in">CGFloat</span>(height))), cgImage)</div><div class="line">let scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(context).flatMap &#123; <span class="built_in">UIImage</span>(<span class="built_in">CGImage</span>: $<span class="number">0</span>) &#125;</div></pre></td></tr></table></figure>
<h4 id="CGImageSourceCreateThumbnailAtIndex"><a href="#CGImageSourceCreateThumbnailAtIndex" class="headerlink" title="CGImageSourceCreateThumbnailAtIndex"></a>CGImageSourceCreateThumbnailAtIndex</h4><p>也可以使用Image I/O的framework也可以用来缩放图片大小.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import ImageIO</div><div class="line"></div><div class="line"><span class="keyword">if</span> let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(<span class="keyword">self</span>.URL, <span class="literal">nil</span>) &#123;</div><div class="line">    let options: [<span class="built_in">NSString</span>: <span class="built_in">NSObject</span>] = [</div><div class="line">        kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) / <span class="number">2.0</span>,</div><div class="line">        kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span></div><div class="line">    ]</div><div class="line"></div><div class="line">    let scaledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options).flatMap &#123; <span class="built_in">UIImage</span>(<span class="built_in">CGImage</span>: $<span class="number">0</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用CoreImage进行Lanczos重新采样"><a href="#使用CoreImage进行Lanczos重新采样" class="headerlink" title="使用CoreImage进行Lanczos重新采样"></a>使用CoreImage进行Lanczos重新采样</h4><p>CoreImage中内置Lanczos Resampling,具体的函数是<code>CILanczosScaleTransform</code> filter.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let image = <span class="built_in">CIImage</span>(contentsOfURL: <span class="keyword">self</span>.URL)</div><div class="line"></div><div class="line">let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)!</div><div class="line">filter.setValue(image, forKey: <span class="string">"inputImage"</span>)</div><div class="line">filter.setValue(<span class="number">0.5</span>, forKey: <span class="string">"inputScale"</span>)</div><div class="line">filter.setValue(<span class="number">1.0</span>, forKey: <span class="string">"inputAspectRatio"</span>)</div><div class="line">let outputImage = filter.valueForKey(<span class="string">"outputImage"</span>) as! <span class="built_in">CIImage</span></div><div class="line"></div><div class="line">let context = <span class="built_in">CIContext</span>(options: [kCIContextUseSoftwareRenderer: <span class="literal">false</span>])</div><div class="line">let scaledImage = <span class="built_in">UIImage</span>(<span class="built_in">CGImage</span>: <span class="keyword">self</span>.context.createCGImage(outputImage, fromRect: outputImage.extent()))</div></pre></td></tr></table></figure>
<h4 id="在Accelerate中的vImage"><a href="#在Accelerate中的vImage" class="headerlink" title="在Accelerate中的vImage"></a>在Accelerate中的vImage</h4><p>使用Accelerat framework包括<code>vImage</code>的图像处理函数.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">let cgImage = <span class="built_in">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.URL.absoluteString!).CGImage</div><div class="line"></div><div class="line"><span class="comment">// create a source buffer</span></div><div class="line">var format = vImage_CGImageFormat(bitsPerComponent: <span class="number">8</span>, bitsPerPixel: <span class="number">32</span>, colorSpace: <span class="literal">nil</span>, </div><div class="line">    bitmapInfo: <span class="built_in">CGBitmapInfo</span>(rawValue: <span class="built_in">CGImageAlphaInfo</span>.First.rawValue), </div><div class="line">    version: <span class="number">0</span>, decode: <span class="literal">nil</span>, renderingIntent: <span class="built_in">CGColorRenderingIntent</span>.RenderingIntentDefault)</div><div class="line">var sourceBuffer = vImage_Buffer()</div><div class="line">defer &#123;</div><div class="line">    sourceBuffer.data.dealloc(Int(sourceBuffer.height) * Int(sourceBuffer.height) * <span class="number">4</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer, &amp;format, <span class="literal">nil</span>, cgImage, numericCast(kvImageNoFlags))</div><div class="line">guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// create a destination buffer</span></div><div class="line">let scale = <span class="built_in">UIScreen</span>.mainScreen().scale</div><div class="line">let destWidth = Int(image.size.width * <span class="number">0.5</span> * scale)</div><div class="line">let destHeight = Int(image.size.height * <span class="number">0.5</span> * scale)</div><div class="line">let bytesPerPixel = <span class="built_in">CGImageGetBitsPerPixel</span>(image.CGImage) / <span class="number">8</span></div><div class="line">let destBytesPerRow = destWidth * bytesPerPixel</div><div class="line">let destData = UnsafeMutablePointer&lt;<span class="built_in">UInt8</span>&gt;.alloc(destHeight * destBytesPerRow)</div><div class="line">defer &#123;</div><div class="line">    destData.dealloc(destHeight * destBytesPerRow)</div><div class="line">&#125;</div><div class="line">var destBuffer = vImage_Buffer(data: destData, height: vImagePixelCount(destHeight), width: vImagePixelCount(destWidth), rowBytes: destBytesPerRow)</div><div class="line"></div><div class="line"><span class="comment">// scale the image</span></div><div class="line">error = vImageScale_ARGB8888(&amp;sourceBuffer, &amp;destBuffer, <span class="literal">nil</span>, numericCast(kvImageHighQualityResampling))</div><div class="line">guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// create a CGImage from vImage_Buffer</span></div><div class="line">let destCGImage = vImageCreateCGImageFromBuffer(&amp;destBuffer, &amp;format, <span class="literal">nil</span>, <span class="literal">nil</span>, numericCast(kvImageNoFlags), &amp;error)?.takeRetainedValue()</div><div class="line">guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// create a UIImage</span></div><div class="line">let scaledImage = destCGImage.flatMap &#123; <span class="built_in">UIImage</span>(<span class="built_in">CGImage</span>: $<span class="number">0</span>, scale: <span class="number">0.0</span>, orientation: image.imageOrientation) &#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="各种方式的选择"><a href="#各种方式的选择" class="headerlink" title="各种方式的选择"></a>各种方式的选择</h3><ul>
<li>UIKit,CoreGraphics以及Image I/O的性能优秀.如果仅仅是缩放的话最好使用CoreImage.</li>
<li>日常的图像缩放以后不进行其他操作的话,使用<code>UIGraphicsBeginImageContextWithOptions</code>是最好的选择.</li>
<li>如果对图像质量有更高的要求,最好使用<code>CGBitmapContextCreate</code>和<code>CGContextSetInterpolationQuality</code>.</li>
<li>如果缩放的目的是显示缩略图,那么最好使用<code>CGImageSourceCreateThumbnailAtIndex</code></li>
<li>缩放不要用<code>vImage</code></li>
</ul>
<blockquote>
<p>参考文档: <a href="http://nshipster.com/image-resizing/" target="_blank" rel="external">Image Resizing Techniques</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/04/iOS音频系列(四)/" itemprop="url">
                  iOS音频系列(四)--音频的文件格式和数据格式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-04T23:13:37+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/04/iOS音频系列(四)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/04/iOS音频系列(四)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在音频开发中 .WAVs和.MP3有什么不同呢,或者还有的.AAC和.CAF之前又有什么区别呢,这些概念在这篇文章以后应该会有一定的理解.</p>
<h3 id="文件格式和数据格式"><a href="#文件格式和数据格式" class="headerlink" title="文件格式和数据格式"></a>文件格式和数据格式</h3><p>如果要理解每一个音频文件,就需要了解它的两个部分的内容:文件格式和数据格式.文件格式又称为音频容器,数据格式又可以认为是编码格式.</p>
<p>文件格式(音频容器)描述的是存储在文件系统的文件的本身,而存储在文件中的音频数据是可以被编码成各种各样的格式的.比如,我们常见的CAF文件是一个文件格式(音频容器),它可以用来存储音频编码格式为MP3,LPCM或者其他的音频编码格式.</p>
<h3 id="音频数据格式-音频编码"><a href="#音频数据格式-音频编码" class="headerlink" title="音频数据格式(音频编码)"></a>音频数据格式(音频编码)</h3><p>这里先来理解音频编码,在音频相关的内容中,音频编码是最重要的.</p>
<p>iPhone中支持的音频格式如下:</p>
<p>AAC: 被设计用来取代MP3音频编码的.它会压缩原来的声音,因此会减少存储空间.实际中ACC比MP3更好的压缩率.</p>
<p>AMR: AMR是一个编码格式用于压缩语音的音频编码格式.</p>
<p>linear PCM: 是标准的线性脉冲编码,一般是将模拟声音转化成数字信号,这是一个未压缩的音频格式.由于是未压缩的音频编码格式,因此播放时候用这种格式最是最好的选择,但是会占用过多的空间.</p>
<p>MP3: …</p>
<p>IMA4: …未压缩</p>
<p>…</p>
<h3 id="该选哪个数据音频格式"><a href="#该选哪个数据音频格式" class="headerlink" title="该选哪个数据音频格式"></a>该选哪个数据音频格式</h3><p>首先明确自己有哪些需求:</p>
<ul>
<li>如果用于播放的音频,选用LPCM,IMA4等其他的未压缩或者轻度压缩的音频格式.</li>
<li>如果使用压缩率较高的AAC,MP3等这些iPhone直接硬件支持快速解码(解压缩).但是,硬件解码时候每次只支持一个文件.因此,如果需要同时播放多个需要解码(解压缩)的文件,就需要通过代码进行软件解码,非常慢.</li>
</ul>
<p>所以如何选择数据音频格式,这里有些建议:</p>
<ul>
<li>如果空间足够,那么最好使用的音频编码格式使用LPCM.不仅播放最快,而且可以同时播放多个音乐而不太占用CPU的资源.</li>
<li>如果对空间有要求,最好使用ACC音频编码来进行音乐的播放,IMA4音频编码进行系统声音的编码.</li>
</ul>
<h3 id="多种LPCM的变体"><a href="#多种LPCM的变体" class="headerlink" title="多种LPCM的变体"></a>多种LPCM的变体</h3><p>对于LPCM音频编码是iPhone中使用非压缩音频数据最好的数据格式.同时,根据具体的存储方式,又有多种变种.音频数据可以存储于大端或者小端模式,用float或者integer存储,也可以使用不同的bit-width存储.</p>
<p>而在iPhone中,使用的最平凡的是:little-endian integer 16bit(或者LEI16 short类型)的格式.在Mac中,使用native-endian(和电脑一致) float point 32bit.如果是在Mac上生成音频数据,那么最好生成合适的格式,再转化成iPhone使用的格式.</p>
<h3 id="文件格式-音频容器"><a href="#文件格式-音频容器" class="headerlink" title="文件格式(音频容器)"></a>文件格式(音频容器)</h3><p>iPhone支持许多文件格式(音频容器)包括:MPEG-1(.mp3),MPEG-2 ADTS(.aac),AIFF,CAF,WAVE等.但是通常在iPhone中使用的容器格式就CAF,因为它可以用来封装iPhone所支持的所有音频格式.</p>
<h3 id="Bit-Rates比特率"><a href="#Bit-Rates比特率" class="headerlink" title="Bit Rates比特率"></a>Bit Rates比特率</h3><p>比特率是一个和音频数据格式关系密切的概念.</p>
<p>音频文件的比特率就是只单位时间内传送的bit数,单位是bit/s,kbit/s.更高的比特率会导致更大的文件.我们在使用有些音频数据格式例如AAC或者MP3时,需要我们去设置比特率,这个参数与音频格式在压缩过程的压缩率有关.当我们让比特率变低,那么音频质量就会更差.</p>
<blockquote>
<p>注释: 1kbit/s = 1000bit/s,而不是1024bit/s</p>
</blockquote>
<p>我们需要权衡比特率的大小和声音文件的质量,选择合适的比特率.如果我们使用的是语音声音,那么比特率可以适当低一点.</p>
<p>下面是常见的比特率:</p>
<ul>
<li>32kbit/s: AM 无限电广播的质量</li>
<li>48kbit/s: 很长的语音对话</li>
<li>64kbit/s: 正常长度的语音对话的比特率</li>
<li>96kbit/s: FM广播</li>
<li>128kbit/s: MP3音乐</li>
<li>329kbit/s: CD的比特率</li>
<li>500kbit/s~1411kbit/s: 无损音频编码格式,比如LPCM</li>
</ul>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>最后一个专业术语:采样率.可以见前面的文章.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/iOS音频系列(三)/" itemprop="url">
                  iOS音频系列(三)--AudioQueue
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-02T14:59:55+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/02/iOS音频系列(三)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/02/iOS音频系列(三)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇是AudioQueue的官方文档的笔记。Audio Queue Services可以play和record以下三类任何audio data：</p>
<ul>
<li>Linear PCM.</li>
<li>Any compressed format supported natively on the Apple platform you are developing for.</li>
<li>Any other format for which a user has an installed codec.</li>
</ul>
<p>对于最后一种类型，我们可以在使用AudioQueue同时自己将自己需要的format转化成LPCM。AudioQueue是对mic和speaker的高度抽象，同时可以非常简单的时间音频codecs。与此同时，它也有一些高级功能，例如多个音频的同步播放，回放等等。</p>
<hr>
<h2 id="About-Audio-Queues"><a href="#About-Audio-Queues" class="headerlink" title="About Audio Queues"></a>About Audio Queues</h2><p>这章会了解到audio queue的功能，结构体，以及内部运行的机理。具体的内容包括audio queues，audio queue buffers，audio queue会使用到的callback等。还有就是audio queue的状态以及参数。</p>
<h3 id="What-Is-an-Audio-Queue"><a href="#What-Is-an-Audio-Queue" class="headerlink" title="What Is an Audio Queue?"></a>What Is an Audio Queue?</h3><p>An audio queue 是iOS中play和record audio的对象.底层是<code>AudioQueueRef</code>。Audio queue可以完成以下工作：</p>
<ul>
<li>Connecting to audio hardware</li>
<li>Managing memory</li>
<li>Employing codecs, as needed, for compressed audio formats</li>
<li>Mediating recording or playback</li>
</ul>
<h4 id="Audio-Queue-Architecture"><a href="#Audio-Queue-Architecture" class="headerlink" title="Audio Queue Architecture"></a>Audio Queue Architecture</h4><p>Audio queue的具体结构有以下几个部分构成：</p>
<ul>
<li>A set of <strong>audio queue buffers</strong>, each of which is a temporary repository for some audio data</li>
<li>A <strong>buffer queue</strong>, an ordered list for the audio queue buffers</li>
<li>An <strong>audio queue callback</strong> function, that you write</li>
</ul>
<p>根据我们使用audio queue的用途（record or play），具体的结构略有不同，仅仅只是callback函数函数的内容不同。</p>
<h4 id="Audio-Queues-for-Recording"><a href="#Audio-Queues-for-Recording" class="headerlink" title="Audio Queues for Recording"></a>Audio Queues for Recording</h4><p>一个用于record 的audio queue，需要使用<code>AudioQueueNewInput</code>方法创建，它的具体结构如图：</p>
<p><img src="https://developer.apple.com/library/prerelease/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/recording_architecture_2x.png" alt="A recording audio queue"></p>
<h4 id="Audio-Queues-for-Playback"><a href="#Audio-Queues-for-Playback" class="headerlink" title="Audio Queues for Playback"></a>Audio Queues for Playback</h4><p>一个用于play的audio queue，需要使用<code>AudioQueueNewOutput</code>函数创建，</p>
<p><img src="https://developer.apple.com/library/prerelease/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/playback_architecture_2x.png" alt="A playback audio queue"></p>
<h4 id="Audio-Queue-Buffers"><a href="#Audio-Queue-Buffers" class="headerlink" title="Audio Queue Buffers"></a>Audio Queue Buffers</h4><p><strong>audio queue buffer</strong>的数据结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AudioQueueBuffer &#123;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">UInt32</span>   mAudioDataBytesCapacity;</div><div class="line">    <span class="keyword">void</span> *<span class="keyword">const</span>    mAudioData;</div><div class="line">    <span class="built_in">UInt32</span>         mAudioDataByteSize;</div><div class="line">    <span class="keyword">void</span>           *mUserData;</div><div class="line">&#125; AudioQueueBuffer;</div><div class="line"><span class="keyword">typedef</span> AudioQueueBuffer *AudioQueueBufferRef;</div></pre></td></tr></table></figure>
<p>其中<strong>mAudioData</strong>字段表示这个buffer中的有用数据的地址，其他的字段用来辅助audio queue来管理使用这个buffer。一个audio queue可以使用任何数目的buffers。但是我们一般选择3个，比较好管理。</p>
<p>Audio queue通过下面的方式管理它们内部的buffers：</p>
<ul>
<li>An audio queue allocates a buffer when you call the AudioQueueAllocateBuffer function.</li>
<li>When you release an audio queue by calling the AudioQueueDispose function, the queue releases its buffers.</li>
</ul>
<h3 id="The-Buffer-Queue-and-Enqueuing"><a href="#The-Buffer-Queue-and-Enqueuing" class="headerlink" title="The Buffer Queue and Enqueuing"></a>The Buffer Queue and Enqueuing</h3><p>buffer queue是由audio buffers组成的，是audio queue中的buffers。我们前面介绍了audio queue是如何使用callback管理内部的buffers。不论当前是用于record或者是pleyback，将buffer放到audio queue都是需要我们在callback函数中去手动调用的。</p>
<h4 id="The-Recording-Process"><a href="#The-Recording-Process" class="headerlink" title="The Recording Process"></a>The Recording Process</h4><p><img src="https://developer.apple.com/library/prerelease/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/recording_callback_function_2x.png" alt="The recording process"></p>
<ol>
<li>In step 1 , recording begins. The audio queue fills a buffer with acquired data.</li>
<li>In step 2, the first buffer has been filled. The audio queue invokes the callback, handing it the full buffer (buffer 1). The callback (step 3) writes the contents of the buffer to an audio file. At the same time, the audio queue fills another buffer (buffer 2) with freshly acquired data.</li>
<li>In step 4, the callback enqueues the buffer (buffer 1) that it has just written to disk, putting it in line to be filled again. The audio queue again invokes the callback (step 5), handing it the next full buffer (buffer 2). The callback (step 6) writes the contents of this buffer to the audio file. This looping steady state continues until the user stops the recording.</li>
</ol>
<h4 id="The-Playback-Process"><a href="#The-Playback-Process" class="headerlink" title="The Playback Process"></a>The Playback Process</h4><p><img src="https://developer.apple.com/library/prerelease/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/playback_callback_function_2x.png" alt="The playback process"></p>
<h4 id="Controlling-the-Playback-Process"><a href="#Controlling-the-Playback-Process" class="headerlink" title="Controlling the Playback Process"></a>Controlling the Playback Process</h4><p>Audio queue buffers在queue是顺序播放的，我们可以通<code>theAudioQueueEnqueueBufferWithParameters</code>方法来进行控制</p>
<h3 id="The-Audio-Queue-Callback-Function"><a href="#The-Audio-Queue-Callback-Function" class="headerlink" title="The Audio Queue Callback Function"></a>The Audio Queue Callback Function</h3><p>Audio queue在运行过程中会不断的调用callback函数，通常间隔时间和audio queue buffer的大小相关，一般是几秒一次。</p>
<p>audio queue callback主要任务是将audio queue buffer归还给audio queue。callback中通过<code>AudioQueueEnqueueBuffer</code>方法将buffer加载到audio queue的最后。在playback中，可以使用<code>AudioQueueEnqueueBufferWithParameters</code>在enqueue的过程中进行更多的控制。</p>
<h4 id="The-Recording-Audio-Queue-Callback-Function"><a href="#The-Recording-Audio-Queue-Callback-Function" class="headerlink" title="The Recording Audio Queue Callback Function"></a>The Recording Audio Queue Callback Function</h4><p>如果你仅仅使用audio queue去将record的audio data写入file system，callback的方法实现的原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AudioQueueInputCallback (</div><div class="line">    <span class="keyword">void</span>                               *inUserData,</div><div class="line">    AudioQueueRef                      inAQ,</div><div class="line">    AudioQueueBufferRef                inBuffer,</div><div class="line">    <span class="keyword">const</span> AudioTimeStamp               *inStartTime,</div><div class="line">    <span class="built_in">UInt32</span>                             inNumberPacketDescriptions,</div><div class="line">    <span class="keyword">const</span> AudioStreamPacketDescription *inPacketDescs</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一个recording audio queue会触发我们注册的callback，会在callback的参数中传入所有需要的关于audio data的相关信息：</p>
<ul>
<li><strong>inUserData</strong> 是一个自定义的结构体，用来存储audio queueu以及audio queue buffer的状态信息，也包括AudioFileID，audio data format等。</li>
<li><strong>inAQ</strong> 表示哪个audio queue触发这个callback。</li>
<li><strong>inBuffer</strong> 是一个audio queue buffer，它的内容是由audio queue填充的，内部包括最新的audio data。并且这些audio data已经根据初始化时候传递的格式参数格式化好的数据。</li>
<li><strong>inStartTime</strong> 表示这个buffer中的第一个采样的采样时间点，一般app中不太需要这个参数。</li>
<li><strong>inNumberPacketDescriptions</strong> 表示<strong>inPacketDescs</strong>参数中的packet descriptions的个数。如果你是录入VBR format，audio queue就会在callback中提供这个参数，如果是CBR，audio queue就不会使用packet descriptions参数，这个参数会是NULL。</li>
<li><strong>inPacketDescs</strong> 表示buffer中samples相关的一系列的packet descriptions。是否设置同上一个参数。</li>
</ul>
<h4 id="The-Playback-Audio-Queue-Callback-Function"><a href="#The-Playback-Audio-Queue-Callback-Function" class="headerlink" title="The Playback Audio Queue Callback Function"></a>The Playback Audio Queue Callback Function</h4><p>这个片段会介绍如果使用playing audio queue，那么callback应该的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AudioQueueOutputCallback (</div><div class="line">    <span class="keyword">void</span>                  *inUserData,</div><div class="line">    AudioQueueRef         inAQ,</div><div class="line">    AudioQueueBufferRef   inBuffer</div><div class="line">);</div></pre></td></tr></table></figure>
<p>一个playback audio queue会触发这个callback，提供一些关于audio data的有用信息：</p>
<ul>
<li><strong>inUserData</strong> 见上</li>
<li><strong>inAQ</strong> 表示哪个audio queue触发这个callback。</li>
<li><strong>inBuffer</strong> 表示被audio queue设置为空的audio queue buffer，你需要在callback中将其内部信息填满，填充内容是你从AudioFile中读取的audio data。</li>
</ul>
<hr>
<h3 id="Using-Codecs-and-Audio-Data-Formats"><a href="#Using-Codecs-and-Audio-Data-Formats" class="headerlink" title="Using Codecs and Audio Data Formats"></a>Using Codecs and Audio Data Formats</h3><p>我们日常使用Audio Queue Services时，都会使用codecs（audio data coding/decoding componets）用来在不同audio format之间进行转化。</p>
<p>每个audio queue都有一个audio data format，可以在<code>AudioStreamBasicDescription</code>结构体中得到。当我们在ASBD中指定了<code>mFormatID</code>以后，audio queue在向buffer中填充数据时候就会使用相应的codec。同样如果指定sample rate和channel count，audio queue也会同样。具体的过程见下图：</p>
<p><img src="https://developer.apple.com/library/ios/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/recording_codec_2x.png" alt="Audio format conversion during recording"></p>
<ul>
<li>第一步中，app会告知audio queue开始record，同时告诉它使用的的data format。</li>
<li>第二步中，audio queue将获取到的new data使用codec转化成目标format。然后audio queue会调用callback函数，传入格式化以后的audio data。</li>
<li>第三步中，callback函数会将格式化以后的audio data写入file中。</li>
</ul>
<p>整个过程中，callback函数压根就不需要知道data fromat是什么。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/playback_codec_2x.png" alt="Audio format conversion during playback"></p>
<p>在播放过程中，正好和录音过程相反，只需要在创建audio queue时候将data format告知即可。</p>
<hr>
<h3 id="Audio-Queue-Control-and-State"><a href="#Audio-Queue-Control-and-State" class="headerlink" title="Audio Queue Control and State"></a>Audio Queue Control and State</h3><p>audio queue在创建和销毁的过程有一个声明周期。app需要管理它的声明周期，控制它的状态，具体控制状态的方法如下：</p>
<ul>
<li>Start (<code>AudioQueueStart</code>).初始化audio queue用来record或者playback。</li>
<li>Prime (<code>AudioQueuePrime</code>).对于playback，在调用<code>AudioQueueStart</code>挚爱去哪调用确保数据可用，这个方法和record没有关系。</li>
<li>Stop (<code>AudioQueueStop</code>). 调用以后会重置audio queue，然后会停止record或者playback。在playback应用中，一般在没有audio data可以播放时候调用。</li>
<li>Pause (<code>AudioQueuePause</code>). 在record或者playback中调用这个方法不会影响到buffers。如果需要恢复，调用<code>AudioQueueStart</code>。</li>
<li>Flush (<code>AudioQueueFlush</code>). 在enqueue最后一个audio queue buffer以后调用这个方法，确保所有的数据被record或者play（主要是在midst processing的数据）。</li>
<li>Reset (<code>AudioQueueReset</code>). 调用以后立即停止audio queue，然后将所有的buffers移除，重置所有的DSP状态等到。</li>
</ul>
<p>在调用<code>AudioQueueStop</code>方法时候有两种模式：同步和异步。</p>
<ul>
<li>Synchronous stopping happens immediately, without regard for previously buffered audio data.</li>
<li>Asynchronous stopping happens after all queued buffers have been played or recorded.</li>
</ul>
<hr>
<h2 id="Recording-Audio"><a href="#Recording-Audio" class="headerlink" title="Recording Audio"></a>Recording Audio</h2><p>当我们的record使用Audio Queue Services，存储的路径可以是磁盘上的任何地方，或者网络，或者内存中。这部分内容记录大多数的使用场景，存储在磁盘中。</p>
<p>具体的步骤如下：</p>
<ol>
<li>定义一个结构体去存储状态，format，文件路径等信息。</li>
<li>完成audio queue callback函数，其中将record以后的数据进行存储。</li>
<li>为audio queue buffers计算出合适的大小，并且在file中写入magic cookies。</li>
<li>初始化自定义的结构体</li>
<li>创建recording audio queue，然后给它创建3个audio queue buffers，然后创建一个file用来存储record以后的audio data。</li>
<li>启动audio queue</li>
<li>当audio queue停止以后，dispose它以及buffers</li>
</ol>
<p>具体的实现内容可以参考Apple官方文档：<a href="https://developer.apple.com/library/prerelease/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AQRecord/RecordingAudio.html" target="_blank" rel="external">Recording Audio</a>。</p>
<h2 id="Playing-Audio"><a href="#Playing-Audio" class="headerlink" title="Playing Audio"></a>Playing Audio</h2><p>当我们使用Audio Queue Service去play audio时，音频源文件可以是任何在disk file或者memory中，这部分内容是如何用Audio Queue Service播放存储在disk上的audio file。</p>
<p>具体的步骤如下：</p>
<ol>
<li>定义一个结构体管理Audio queue的状态，format，file path等</li>
<li>完成audio queue callback函数去进行实际的播放</li>
<li>创建一个函数用来计算最适合的audio queue buffer的大小</li>
<li>打开audio file，确定它的audio data format</li>
<li>创建audio queue，对它进行配置</li>
<li>为audio queue创建buffers，然后启动audio queue，当播放结束，callback让audio queue停止播放</li>
<li>销毁audio queue</li>
</ol>
<p>具体的实现内容可以参考Apple官方文档：<a href="https://developer.apple.com/library/prerelease/content/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AQPlayback/PlayingAudio.html" target="_blank" rel="external">Playing Audio</a>。</p>
<h2 id="可运行的Demo"><a href="#可运行的Demo" class="headerlink" title="可运行的Demo"></a>可运行的Demo</h2><p>请参考我的github: <a href="https://github.com/brownfeng/AudioQueueServiceDemo" target="_blank" rel="external">https://github.com/brownfeng/AudioQueueServiceDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/31/iOS音频系列(二)/" itemprop="url">
                  iOS音频系列(二)--CoreAudio
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-31T22:37:02+08:00" content="2016-07-31">
              2016-07-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/31/iOS音频系列(二)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/31/iOS音频系列(二)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇主要是CoreAudio官方文档的重点内容的笔记。</p>
<h3 id="通过回调函数与CoreAudio交互"><a href="#通过回调函数与CoreAudio交互" class="headerlink" title="通过回调函数与CoreAudio交互"></a>通过回调函数与CoreAudio交互</h3><p>iOS的CoreAudio是通过callback函数与App交互的。其中需要设置回调函数有以下几种情况：</p>
<ul>
<li>CoreAudio会向回调函数给App传入PCM音频数据，然后App需要在回调函数中将音频数据写入文件文件系统。（录音时候）</li>
<li>CoreAudio会需要向App请求一些音频数据，App通过从文件系统中读取音频数据，然后通过callback函数传递给CoreAudio。（播放时候）</li>
<li>通过注册属性观察者，监听CoreAudio的属性，注册回调函数</li>
</ul>
<p>下面是一个使用Audio Queue Services的属性监听器的callback函数的调用模板。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef void (*AudioQueuePropertyListenerProc) (</div><div class="line">                void *                  inUserData,</div><div class="line">                AudioQueueRef           inAQ,</div><div class="line">                AudioQueuePropertyID    inID</div><div class="line">            );</div></pre></td></tr></table></figure>
<p>在实现和使用这个callback函数时候，你需要完成两件事：</p>
<ul>
<li>实现这个函数。例如，你可以实现property listener callback，根据audio是否在running或者stop状态，去改变更新UI。</li>
<li>注册callback函数时候带上userData数据，在callback函数触发时候使用。</li>
</ul>
<p>下面是一个property listener callback函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static void propertyListenerCallback (</div><div class="line">    void                    *inUserData,</div><div class="line">    AudioQueueRef           queueObject,</div><div class="line">    AudioQueuePropertyID    propertyID</div><div class="line">) &#123;</div><div class="line">    AudioPlayer *player = (AudioPlayer *) inUserData;</div><div class="line">        // gets a reference to the playback object</div><div class="line">    [player.notificationDelegate updateUserInterfaceOnAudioQueueStateChange: player];</div><div class="line">        // your notificationDelegate class implements the UI update method</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是注册一个callback函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AudioQueueAddPropertyListener (</div><div class="line">    self.queueObject,                // the object that will invoke your callback</div><div class="line">    kAudioQueueProperty_IsRunning,   // the ID of the property you want to listen for</div><div class="line">    propertyListenerCallback,        // a reference to your callback function</div><div class="line">    self</div><div class="line">);</div></pre></td></tr></table></figure>
<hr>
<h3 id="Audio-Data-Formats"><a href="#Audio-Data-Formats" class="headerlink" title="Audio Data Formats"></a>Audio Data Formats</h3><p>这部分内容是iOS中支持的音频格式，理解以后对后面的音频相关的编程能够理解更加深刻。</p>
<h4 id="iOS中通用的音频数据类型"><a href="#iOS中通用的音频数据类型" class="headerlink" title="iOS中通用的音频数据类型"></a>iOS中通用的音频数据类型</h4><p>在CoreAudio中，使用<code>AudioStreamBasicDescription</code>和<code>AudioStreamPacketDescription</code>这两个类型描述了通用的音频数据类型,包括压缩音频数据，非压缩的音频数据。他们的数据结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> AudioStreamBasicDescription &#123;</div><div class="line">    Float64 mSampleRate;</div><div class="line">    <span class="built_in">UInt32</span>  mFormatID;</div><div class="line">    <span class="built_in">UInt32</span>  mFormatFlags;</div><div class="line">    <span class="built_in">UInt32</span>  mBytesPerPacket;</div><div class="line">    <span class="built_in">UInt32</span>  mFramesPerPacket;</div><div class="line">    <span class="built_in">UInt32</span>  mBytesPerFrame;</div><div class="line">    <span class="built_in">UInt32</span>  mChannelsPerFrame;</div><div class="line">    <span class="built_in">UInt32</span>  mBitsPerChannel;</div><div class="line">    <span class="built_in">UInt32</span>  mReserved;				<span class="comment">//0</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AudioStreamBasicDescription  AudioStreamBasicDescription;</div><div class="line"></div><div class="line"><span class="keyword">struct</span>  AudioStreamPacketDescription &#123;</div><div class="line">    SInt64  mStartOffset;</div><div class="line">    <span class="built_in">UInt32</span>  mVariableFramesInPacket;</div><div class="line">    <span class="built_in">UInt32</span>  mDataByteSize;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AudioStreamPacketDescription AudioStreamPacketDescription;</div></pre></td></tr></table></figure>
<blockquote>
<p>compressed audio formats use a varying number of bits per sample. For these formats, the value of the mBitsPerChannel member is 0.</p>
</blockquote>
<h4 id="Audio-Data-Packets"><a href="#Audio-Data-Packets" class="headerlink" title="Audio Data Packets"></a>Audio Data Packets</h4><p>前面定义过，将一个或者多个frames称为一个packet。或者说packet是最有意义的一组frames，它在audio file中代表一个有意义的时间单元。使用Core Audio中一般是对packets进行处理的。</p>
<p>每个audio data格式在packets被装配完成以后，它的fromat就被确定了。ASBD数据结构通过<code>mBytesPerPacket</code>和<code>mFramesPerPacket</code>描述音频格式的packet信息，其中页包含其他的信息。</p>
<p>在整个Core Audio中可能会用到三种不同的packets：</p>
<ul>
<li>CBR (constant bit rate) formats：例如 linear PCM and IMA/ADPCM，所有的packet使用相同的大小。</li>
<li>VBR (variable bit rate) formats：例如 AAC，Apple Lossless，MP3，所有的packets拥有相同的frames，但是每个sample中的bits数目不同。</li>
<li>VFR (variable frame rate) formats：packets拥有数目不同的的frames。</li>
</ul>
<p>在Core Audio中使用VBR或者VFR格式，使用ASPD结构体只能用来描述单个packet。如果是record或者play VBR或者VFR音频文件，需要涉及到多个ASPD结构。</p>
<p>在AudioFileService等接口中，都是通过pakcets工作的。例如<code>AudioFileReadPackets</code>会得到一系列的packets，同时会得到一个数组的<code>AudioStreamPacketDescription</code>。</p>
<p>下面是通过packets计算audio data buffer的大小：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) calculateSizesFor: (Float64) seconds &#123;</div><div class="line"> </div><div class="line">    <span class="built_in">UInt32</span> maxPacketSize;</div><div class="line">    <span class="built_in">UInt32</span> propertySize = <span class="keyword">sizeof</span> (maxPacketSize);</div><div class="line"> </div><div class="line">    AudioFileGetProperty (</div><div class="line">        audioFileID,</div><div class="line">        kAudioFilePropertyPacketSizeUpperBound,</div><div class="line">        &amp;propertySize,</div><div class="line">        &amp;maxPacketSize</div><div class="line">    );</div><div class="line"> </div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> maxBufferSize = <span class="number">0x10000</span>;   <span class="comment">// limit maximum size to 64K</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> minBufferSize = <span class="number">0x4000</span>;    <span class="comment">// limit minimum size to 16K</span></div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (audioFormat.mFramesPerPacket) &#123;</div><div class="line">        Float64 numPacketsForTime =</div><div class="line">            audioFormat.mSampleRate / audioFormat.mFramesPerPacket * seconds;</div><div class="line">        [<span class="keyword">self</span> setBufferByteSize: numPacketsForTime * maxPacketSize];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// if frames per packet is zero, then the codec doesn't know the</span></div><div class="line">        <span class="comment">// relationship between packets and time. Return a default buffer size</span></div><div class="line">        [<span class="keyword">self</span> setBufferByteSize:</div><div class="line">            maxBufferSize &gt; maxPacketSize ? maxBufferSize : maxPacketSize];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// clamp buffer size to our specified range</span></div><div class="line">    <span class="keyword">if</span> (bufferByteSize &gt; maxBufferSize &amp;&amp; bufferByteSize &gt; maxPacketSize) &#123;</div><div class="line">        [<span class="keyword">self</span> setBufferByteSize: maxBufferSize];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (bufferByteSize &lt; minBufferSize) &#123;</div><div class="line">            [<span class="keyword">self</span> setBufferByteSize: minBufferSize];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    [<span class="keyword">self</span> setNumPacketsToRead: <span class="keyword">self</span>.bufferByteSize / maxPacketSize];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Data-Format-Conversion"><a href="#Data-Format-Conversion" class="headerlink" title="Data Format Conversion"></a>Data Format Conversion</h4><p>将音频数据从一种audio data转换成另外一种audio data。常见的有三中音频格式转换：</p>
<ul>
<li>Decoding an audio format (such as AAC (Advanced Audio Coding)) to linear PCM format.</li>
<li>Converting linear PCM data into a different audio format.</li>
<li>Converting between different variants of linear PCM (for example, converting 16-bit signed integer linear PCM to 8.24 fixed-point linear PCM).</li>
</ul>
<hr>
<h3 id="Sound-Files"><a href="#Sound-Files" class="headerlink" title="Sound Files"></a>Sound Files</h3><p>如果要使用声音文件，你需要使用Audio File Services的接口。一般而且，在iOS中需要与音频文件的创建，操作都离不开Audio File Services。</p>
<p>使用<code>AudioFileGetGlobalInfoSize</code>和<code>AudioFileGetGlobalInfo</code>分别分配info的内存和获取info的内容。你可以获取以下的内容：</p>
<ul>
<li>Readable file types</li>
<li>Writable file types</li>
<li>For each writable type, the audio data formats you can put into the file</li>
</ul>
<h4 id="Creating-a-New-Sound-File"><a href="#Creating-a-New-Sound-File" class="headerlink" title="Creating a New Sound File"></a>Creating a New Sound File</h4><p>为了创建一个能够存储音频数据的audio file，你需要进行以下三步：</p>
<ul>
<li>使用CFURL或者NSURL表示的系统文件的路径</li>
<li>你需要创建的文件的类型的标识identifier，这些identifier定义在<code>Audio File Types</code>枚举中。例如，为了创建一个CAF文件，你需要使用<code>kAudioFileCAFType</code>的identifier。</li>
<li>创建过程中你需要提供音频数据的ASBD结构体。为了获取ASBD，你可以先提供ASBD结构体的部分成员的值，然后通过函数让<code>Audio File Services</code>将剩余的信息填满。</li>
</ul>
<p>下面是创建一个AudioFile的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AudioFileCreateWithURL (</div><div class="line">    audioFileURL,</div><div class="line">    kAudioFileCAFType,</div><div class="line">    &amp;audioFormat,</div><div class="line">    kAudioFileFlags_EraseFile,</div><div class="line">    &amp;audioFileID   <span class="comment">// the function provides the new file object here</span></div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="Opening-a-Sound-File"><a href="#Opening-a-Sound-File" class="headerlink" title="Opening a Sound File"></a>Opening a Sound File</h4><p>为了打开sound file，需要使用<code>AudioFileOpenURL</code>函数，该函数会返回一个唯一ID，供后面使用。</p>
<p>为了获取sound file的一些属性，通常使用<code>AudioFileGetPropertyInfo</code>和<code>AudioFileGetProperty</code>，日常使用的属性以下：</p>
<ul>
<li>kAudioFilePropertyFileFormat</li>
<li>kAudioFilePropertyDataFormat</li>
<li>kAudioFilePropertyMagicCookieData</li>
<li>kAudioFilePropertyChannelLayout</li>
</ul>
<h4 id="Reading-From-and-Writing-To-a-Sound-File"><a href="#Reading-From-and-Writing-To-a-Sound-File" class="headerlink" title="Reading From and Writing To a Sound File"></a>Reading From and Writing To a Sound File</h4><p>iOS中，我们经常需要使用<code>Audio File Services</code>去读写audio data到sound file中。读和写是一对相反的内容，操作的对象都可以是bytes或者packets，但是一般而言都是直接使用的packets。</p>
<blockquote>
<ul>
<li>读写VBR数据，只能使用packet</li>
<li>直接使用packet，更加容易计算时间</li>
</ul>
</blockquote>
<hr>
<h3 id="iPhone-Audio-File-Formats"><a href="#iPhone-Audio-File-Formats" class="headerlink" title="iPhone Audio File Formats"></a>iPhone Audio File Formats</h3><p>iOS支持的sound file格式如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Format name</th>
<th style="text-align:center">Format filename extensions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AIFF</td>
<td style="text-align:center">.aif, .aiff</td>
</tr>
<tr>
<td style="text-align:center">CAF</td>
<td style="text-align:center">.caf</td>
</tr>
<tr>
<td style="text-align:center">MPEG-1, layer 3</td>
<td style="text-align:center">.mp3</td>
</tr>
<tr>
<td style="text-align:center">MPEG-2 or MPEG-4 ADTS</td>
<td style="text-align:center">.aac</td>
</tr>
<tr>
<td style="text-align:center">MPEG-4</td>
<td style="text-align:center">.m4a, .mp4</td>
</tr>
<tr>
<td style="text-align:center">WAV</td>
<td style="text-align:center">.wav</td>
</tr>
</tbody>
</table>
<p>iOS中的native format是CAF file format。</p>
<hr>
<h3 id="Audio-Sessions-Cooperating-with-Core-Audio"><a href="#Audio-Sessions-Cooperating-with-Core-Audio" class="headerlink" title="Audio Sessions: Cooperating with Core Audio"></a>Audio Sessions: Cooperating with Core Audio</h3><p>在iOS中，app在运行过程中有可能接到电话，如果此时正在播放sound，系统会做一定的处理。</p>
<p>AudioSession就是在这种情况的中间人，每个app都会有一个audio session。在播放或者录音时候需要session在做正确的事情，需要我们自己弄清楚以下的情况：</p>
<ul>
<li>app收到系统的中断时候应该如何响应，比如收到phone call？</li>
<li>你是否需要app的sound和其他后台运行的app的sounds混合播放，或者需要独占播放？</li>
<li>你需要app如何响应远音频路径的响应，比如拔插耳机时候</li>
</ul>
<p>AudioSession提供了三种类型的接口：</p>
<ul>
<li><strong>Categories</strong>： A category is a key that identifies a set of audio behaviors for your application. By setting a category, you indicate your audio intentions to iOS, such as whether your audio should continue when the screen locks.</li>
<li><strong>Interruptions and route changes</strong> ：Your audio session posts notifications when your audio is interrupted, when an interruption ends, and when the hardware audio route changes. These notifications let you respond to changes in the larger audio environment—such as an interruption due to in an incoming phone call—gracefully.</li>
<li><strong>Hardware characteristics</strong>：You can query the audio session to discover characteristics of the device your application is running on, such as hardware sample rate, number of hardware channels, and whether audio input is available.</li>
</ul>
<h4 id="Audio-Session-Default-Behavior"><a href="#Audio-Session-Default-Behavior" class="headerlink" title="Audio Session Default Behavior"></a>Audio Session Default Behavior</h4><p>Audio Session拥有一些默认的行为策略：</p>
<ul>
<li>当用户将静音开关静音时，audio就会静音。</li>
<li>当用户锁屏（手动，自动）时候，audio就会静音。</li>
<li>当你app的audio启动时，其他app正在使用的audio就会静音。</li>
</ul>
<p>audio session的这个特定的默认的行为策略被称为<code>kAudioSessionCategory_SoloAmbientSound</code>。同时，它还包括其他的多种策略选择。</p>
<h4 id="Interruptions-Deactivation-and-Activation"><a href="#Interruptions-Deactivation-and-Activation" class="headerlink" title="Interruptions: Deactivation and Activation"></a>Interruptions: Deactivation and Activation</h4><p>默认的audio session的一个典型的特征是，audio会在中断以后自动恢复活动。Audio session有两个重要的状态：<code>active</code>和<code>inactive</code>。只有当Audio session处于<code>active</code>状态时候，app才能使用audio。</p>
<p>在app启动以后，你的默认的audio session就会是<code>active</code>状态。然而，如果一个电话被打进来，你的session就会立刻被置为<code>inactive</code>，然后app中的audio就会停止。这个电话就被称为一个中断，如果用户选择忽略电话，app就会继续运行。但是此时你的audio session依然会是<code>inactive</code>状态，audio也就不会工作。</p>
<p>如果你使用 Audio Queue Services操作audio，我们就需要给中断注册listener回调函数，手动去重启audio session。具体内容可以见<code>Audio Session Programming Guide</code>。</p>
<h4 id="Determining-if-Audio-Input-is-Available"><a href="#Determining-if-Audio-Input-is-Available" class="headerlink" title="Determining if Audio Input is Available"></a>Determining if Audio Input is Available</h4><p>一个录音的app只有在设备的音频硬件可用的时候才能录音。为了检查这个属性，需要使用audio session的<code>kAudioSessionProperty_AudioInputAvailable</code>属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UInt32</span> audioInputIsAvailable;</div><div class="line"><span class="built_in">UInt32</span> propertySize = <span class="keyword">sizeof</span> (audioInputIsAvailable);</div><div class="line"> </div><div class="line">AudioSessionGetProperty (</div><div class="line">    kAudioSessionProperty_AudioInputAvailable,</div><div class="line">    &amp;propertySize,</div><div class="line">    &amp;audioInputIsAvailable <span class="comment">// A nonzero value on output means that</span></div><div class="line">                           <span class="comment">// audio input is available</span></div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="Using-Your-Audio-Session"><a href="#Using-Your-Audio-Session" class="headerlink" title="Using Your Audio Session"></a>Using Your Audio Session</h4><p>你的app同时只能有一个audio session策略，你的所有的audio都需要遵循这个<code>active</code>策略的特点。如何响应中断，在Audio Session Programming Guide`中有更加详细的内容。</p>
<blockquote>
<p>如果要测试Audio session，需要使用真机</p>
</blockquote>
<hr>
<h3 id="Playback-using-the-AVAudioPlayer-Class"><a href="#Playback-using-the-AVAudioPlayer-Class" class="headerlink" title="Playback using the AVAudioPlayer Class"></a>Playback using the AVAudioPlayer Class</h3><p><code>AVAudioPlayer</code>提供了简单的OC接口用于audio播放。如果非网络stream，或者需要精确控制，apple推荐使用这个类，它可以用于播放iOS支持的任何audio format，同时这个类并不需要去设置audio session，因为它会在中断发生以后自动恢复播放，除非你需要指定特地的行为。</p>
<p>它可以完成以下工作：</p>
<ul>
<li>Play sounds of any duration</li>
<li>Play sounds from files or memory buffers</li>
<li>Loop sounds</li>
<li>Play multiple sounds simultaneously</li>
<li>Control relative playback level for each sound you are playing</li>
<li>Seek to a particular point in a sound file, which supports such application features as fast forward and rewind</li>
<li>Obtain data that you can use for audio level metering</li>
</ul>
<p>下面就是使用<code>AVAudioPlayer</code>的具体流程：</p>
<ol>
<li>Configuring an AVAudioPlayer object</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *soundFilePath =</div><div class="line">                [[<span class="built_in">NSBundle</span> mainBundle] pathForResource: <span class="string">@"sound"</span></div><div class="line">                                                ofType: <span class="string">@"wav"</span>];</div><div class="line"> </div><div class="line"><span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSURL</span> alloc] initFileURLWithPath: soundFilePath];</div><div class="line"> </div><div class="line"><span class="built_in">AVAudioPlayer</span> *newPlayer =</div><div class="line">                [[<span class="built_in">AVAudioPlayer</span> alloc] initWithContentsOfURL: fileURL</div><div class="line">                                                       error: <span class="literal">nil</span>];</div><div class="line">[fileURL release];</div><div class="line"> </div><div class="line"><span class="keyword">self</span>.player = newPlayer;</div><div class="line">[newPlayer release];</div><div class="line"> </div><div class="line">[<span class="keyword">self</span>.player prepareToPlay];</div><div class="line">[<span class="keyword">self</span>.player setDelegate: <span class="keyword">self</span>];</div></pre></td></tr></table></figure>
<p>你的delegate对象用于处理<code>interruptions</code>或者音频播放停止以后的操作。</p>
<ol>
<li>Implementing an AVAudioPlayer delegate method </li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) audioPlayerDidFinishPlaying: (<span class="built_in">AVAudioPlayer</span> *) player</div><div class="line">                        successfully: (<span class="built_in">BOOL</span>) flag &#123;</div><div class="line">    <span class="keyword">if</span> (flag == <span class="literal">YES</span>) &#123;</div><div class="line">        [<span class="keyword">self</span>.button setTitle: <span class="string">@"Play"</span> forState: <span class="built_in">UIControlStateNormal</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>Controlling an AVAudioPlayer object</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>) playOrPause: (<span class="keyword">id</span>) sender &#123;</div><div class="line"> </div><div class="line">    <span class="comment">// if already playing, then pause</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.player.playing) &#123;</div><div class="line">        [<span class="keyword">self</span>.button setTitle: <span class="string">@"Play"</span> forState: <span class="built_in">UIControlStateHighlighted</span>];</div><div class="line">        [<span class="keyword">self</span>.button setTitle: <span class="string">@"Play"</span> forState: <span class="built_in">UIControlStateNormal</span>];</div><div class="line">        [<span class="keyword">self</span>.player pause];</div><div class="line"> </div><div class="line">    <span class="comment">// if stopped or paused, start playing</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.button setTitle: <span class="string">@"Pause"</span> forState: <span class="built_in">UIControlStateHighlighted</span>];</div><div class="line">        [<span class="keyword">self</span>.button setTitle: <span class="string">@"Pause"</span> forState: <span class="built_in">UIControlStateNormal</span>];</div><div class="line">        [<span class="keyword">self</span>.player play];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="Recording-and-Playback-using-Audio-Queue-Services"><a href="#Recording-and-Playback-using-Audio-Queue-Services" class="headerlink" title="Recording and Playback using Audio Queue Services"></a>Recording and Playback using Audio Queue Services</h3><p>Audio Queue Services是一个更加直观的record和play audio的方式。同时它还有更多个高级功能，可以使用这个服务完成更多的工作，比如对LPCM数据进行压缩等等。它和<code>AVAudioPlayer</code>是iOS中唯二可以播放压缩后音频格式的接口。使用Audio Queue Service播放和录音都是通过回调方法完成的。</p>
<h4 id="Creating-an-Audio-Queue-Object"><a href="#Creating-an-Audio-Queue-Object" class="headerlink" title="Creating an Audio Queue Object"></a>Creating an Audio Queue Object</h4><p>为了创建Audio Queue对象，它分成两类：</p>
<ul>
<li>AudioQueueNewInput用于录音</li>
<li>AudioQueueNewOutput用于播放</li>
</ul>
<p>使用audio queue object播放audio file，需要一些几个步骤：</p>
<ol>
<li>创建数据结构用于管理audio queue需要的信息，例如audio format，audio fileID等。</li>
<li>定义callback函数，用于管理audio queue buffers。callback会使用Audio File Service去读取audio file用来播放</li>
<li>使用AudioQueueNewOutput用来播放audio file。</li>
</ol>
<p>Creating an audio queue object具体的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumberBuffers = <span class="number">3</span>;</div><div class="line"><span class="comment">// Create a data structure to manage information needed by the audio queue</span></div><div class="line"><span class="keyword">struct</span> myAQStruct &#123;</div><div class="line">    AudioFileID                     mAudioFile;</div><div class="line">    <span class="built_in">CAStreamBasicDescription</span>        mDataFormat;</div><div class="line">    AudioQueueRef                   mQueue;</div><div class="line">    AudioQueueBufferRef             mBuffers[kNumberBuffers];</div><div class="line">    SInt64                          mCurrentPacket;</div><div class="line">    <span class="built_in">UInt32</span>                          mNumPacketsToRead;</div><div class="line">    AudioStreamPacketDescription    *mPacketDescs;</div><div class="line">    <span class="keyword">bool</span>                            mDone;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Define a playback audio queue callback function</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> AQTestBufferCallback(</div><div class="line">    <span class="keyword">void</span>                   *inUserData,</div><div class="line">    AudioQueueRef          inAQ,</div><div class="line">    AudioQueueBufferRef    inCompleteAQBuffer</div><div class="line">) &#123;</div><div class="line">    myAQStruct *myInfo = (myAQStruct *)inUserData;</div><div class="line">    <span class="keyword">if</span> (myInfo-&gt;mDone) <span class="keyword">return</span>;</div><div class="line">    <span class="built_in">UInt32</span> numBytes;</div><div class="line">    <span class="built_in">UInt32</span> nPackets = myInfo-&gt;mNumPacketsToRead;</div><div class="line"> </div><div class="line">    AudioFileReadPackets (</div><div class="line">        myInfo-&gt;mAudioFile,</div><div class="line">        <span class="literal">false</span>,</div><div class="line">        &amp;numBytes,</div><div class="line">        myInfo-&gt;mPacketDescs,</div><div class="line">        myInfo-&gt;mCurrentPacket,</div><div class="line">        &amp;nPackets,</div><div class="line">        inCompleteAQBuffer-&gt;mAudioData</div><div class="line">    );</div><div class="line">    <span class="keyword">if</span> (nPackets &gt; <span class="number">0</span>) &#123;</div><div class="line">        inCompleteAQBuffer-&gt;mAudioDataByteSize = numBytes;</div><div class="line">        AudioQueueEnqueueBuffer (</div><div class="line">            inAQ,</div><div class="line">            inCompleteAQBuffer,</div><div class="line">            (myInfo-&gt;mPacketDescs ? nPackets : <span class="number">0</span>),</div><div class="line">            myInfo-&gt;mPacketDescs</div><div class="line">        );</div><div class="line">        myInfo-&gt;mCurrentPacket += nPackets;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        AudioQueueStop (</div><div class="line">            myInfo-&gt;mQueue,</div><div class="line">            <span class="literal">false</span></div><div class="line">        );</div><div class="line">        myInfo-&gt;mDone = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Instantiate an audio queue object</span></div><div class="line">AudioQueueNewOutput (</div><div class="line">    &amp;myInfo.mDataFormat,</div><div class="line">    AQTestBufferCallback,</div><div class="line">    &amp;myInfo,</div><div class="line">    <span class="built_in">CFRunLoopGetCurrent</span>(),</div><div class="line">    kCFRunLoopCommonModes,</div><div class="line">    <span class="number">0</span>,</div><div class="line">    &amp;myInfo.mQueue</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="Controlling-Audio-Queue-Playback-Level"><a href="#Controlling-Audio-Queue-Playback-Level" class="headerlink" title="Controlling Audio Queue Playback Level"></a>Controlling Audio Queue Playback Level</h4><p>Audio Queue对象提供了两个方式控制音频level。第一种是直接使用<code>AudioQueueSetParameter</code>以及<code>kAudioQueueParam_Volume</code>参数，就可以设置，设置完成以后会立即生效。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Float32 volume = <span class="number">1</span>;</div><div class="line">AudioQueueSetParameter (</div><div class="line">    myAQstruct.audioQueueObject,</div><div class="line">    kAudioQueueParam_Volume,</div><div class="line">    volume</div><div class="line">);</div></pre></td></tr></table></figure>
<p>也可以通过<code>AudioQueueEnqueueBufferWithParameters</code>给audio queue buffer设置。这种方式只有在audio queue buffer 开始播放时候才起作用。</p>
<h4 id="Indicating-Audio-Queue-Playback-Level"><a href="#Indicating-Audio-Queue-Playback-Level" class="headerlink" title="Indicating Audio Queue Playback Level"></a>Indicating Audio Queue Playback Level</h4><p>你也可以直接查询audio queue的<code>kAudioQueueProperty_CurrentLevelMeterDB</code>属性，得到的值是一组<code>AudioQueueLevelMeterState</code>结构体（一个channel一个数组），具体的结构体是<code>AudioQueueLevelMeterState</code>，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct AudioQueueLevelMeterState &#123;</div><div class="line">    Float32     mAveragePower;</div><div class="line">    Float32     mPeakPower;</div><div class="line">&#125;;  AudioQueueLevelMeterState;</div></pre></td></tr></table></figure>
<hr>
<h3 id="System-Sounds-Alerts-and-Sound-Effects"><a href="#System-Sounds-Alerts-and-Sound-Effects" class="headerlink" title="System Sounds: Alerts and Sound Effects"></a>System Sounds: Alerts and Sound Effects</h3><p>如果你需要播放的音频时间少于30s，那么可以使用System Sound Services。调用<code>AudioServicesPlaySystemSound</code>函数可以立即播放一个sound file。你也可以调用<code>AudioServicesPlayAlertSound</code>播放alert声音。这两个方法都会在手机静音的情况下振动。</p>
<p>当然，你也在调用<code>AudioServicesPlaySystemSound</code>方法使用<code>kSystemSoundID_Vibrate</code>属性，显示的触发振动。</p>
<p>为了使用<code>AudioServicesPlaySystemSound</code>方法播放sound，首先需要将sound file注册到系统中，得到一个sound ID，然后才能播放。</p>
<p>下面一段代码显示了使用System Sound Services去play sound：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include <span class="meta-string">&lt;AudioToolbox/AudioToolbox.h&gt;</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="comment">// Define a callback to be called when the sound is finished</span></div><div class="line"><span class="comment">// playing. Useful when you need to free memory after playing.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> MyCompletionCallback (</div><div class="line">    SystemSoundID  mySSID,</div><div class="line">    <span class="keyword">void</span> * myURLRef</div><div class="line">) &#123;</div><div class="line">        AudioServicesDisposeSystemSoundID (mySSID);</div><div class="line">        <span class="built_in">CFRelease</span> (myURLRef);</div><div class="line">        <span class="built_in">CFRunLoopStop</span> (<span class="built_in">CFRunLoopGetCurrent</span>());</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="comment">// Set up the pieces needed to play a sound.</span></div><div class="line">    SystemSoundID    mySSID;</div><div class="line">    <span class="built_in">CFURLRef</span>        myURLRef;</div><div class="line">    myURLRef = <span class="built_in">CFURLCreateWithFileSystemPath</span> (</div><div class="line">        kCFAllocatorDefault,</div><div class="line">        <span class="built_in">CFSTR</span> (<span class="string">"../../ComedyHorns.aif"</span>),</div><div class="line">        kCFURLPOSIXPathStyle,</div><div class="line">        <span class="literal">FALSE</span></div><div class="line">    );</div><div class="line"> </div><div class="line">    <span class="comment">// create a system sound ID to represent the sound file</span></div><div class="line">    OSStatus error = AudioServicesCreateSystemSoundID (myURLRef, &amp;mySSID);</div><div class="line"> </div><div class="line">    <span class="comment">// Register the sound completion callback.</span></div><div class="line">    <span class="comment">// Again, useful when you need to free memory after playing.</span></div><div class="line">    AudioServicesAddSystemSoundCompletion (</div><div class="line">        mySSID,</div><div class="line">        <span class="literal">NULL</span>,</div><div class="line">        <span class="literal">NULL</span>,</div><div class="line">        MyCompletionCallback,</div><div class="line">        (<span class="keyword">void</span> *) myURLRef</div><div class="line">    );</div><div class="line"> </div><div class="line">    <span class="comment">// Play the sound file.</span></div><div class="line">    AudioServicesPlaySystemSound (mySSID);</div><div class="line"> </div><div class="line">    <span class="comment">// Invoke a run loop on the current thread to keep the application</span></div><div class="line">    <span class="comment">// running long enough for the sound to play; the sound completion</span></div><div class="line">    <span class="comment">// callback later stops this run loop.</span></div><div class="line">    <span class="built_in">CFRunLoopRun</span> ();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/30/iOS音频系列(一)/" itemprop="url">
                  iOS音频系列(一)--音频基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-30T17:07:07+08:00" content="2016-07-30">
              2016-07-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/30/iOS音频系列(一)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/30/iOS音频系列(一)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前些日子由于项目需要,一直在研究iOS CoreAudio相关的内容.在这里记录一些笔记.现实生活中，我们听到的声音都是时间连续的，我们称为这种信号叫模拟信号。模拟信号需要进行数字化以后才能在计算机中使用。数字化的过程如下：</p>
<p><code>采样 -&gt; 量化 -&gt; 编码</code></p>
<p>通过获取间隔相同时间的某个模拟信号的值，然后对这些采样以后得到的值进行量化，然后使用一定的bit进行编码存储，整个过程结束后就会输出PCM数据。在iOS的Core Audio Services中使用的音频数据只能是线性PCM格式的音频数据，这是一种未进过压缩的音频数据格式。要理解整个过程就需要理解多个重要概念：采样频率和采样位数，比特率等。</p>
<h3 id="采样频率"><a href="#采样频率" class="headerlink" title="采样频率"></a>采样频率</h3><p>采样频率是指单位时间内对声音模拟信号的采样次数。采样率类似于视频的帧数，比如电影的采样率是24Hz。当我们把采样到的一个个静止画面再以采样率同样的速度回放时，看到的就是连续的画面。同样的道理，把以44.1kHZ采样率记录的CD以同样的速率播放时，就能听到连续的声音。显然，这个采样率越高，听到的声音和看到的图像就越连贯。当然，人的听觉和视觉器官能分辨的采样率是有限的。对同一段声音，用20kHz和44.1kHz来采样，重放时，可能可以听出其中的差别，而基本上高于44.1kHZ采样的声音，比如说96kHz采样，绝大部分人已经觉察不到两种采样出来的声音的分别了。之所以使用44.1kHZ这个数值是因为经过了反复实验，人们发现这个采样精度最合适，低于这个值就会有较明显的损失，而高于这个值人的耳朵已经很难分辨，而且增大了数字音频所占用的空间。我们所使用的CD的采样标准就是44.1k。</p>
<h3 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h3><p>采样位数可以理解为采集卡处理声音的解析度。这个数值越大，解析度就越高，录制和回放的声音就越真实。我们首先要知道：电脑中的声音文件是用数字0和1来表示的。连续的模拟信号按一定的采样频率经数码脉冲取样后，每一个离散的脉冲信号被以一定的量化精度量化成一串二进制编码流，这串编码流的位数即为采样位数，也称为量化精度。</p>
<p>在电脑上录音的本质就是把模拟声音信号转换成数字信号。反之，在播放时则是把数字信号还原成模拟声音信号输出。采集卡的位是指采集卡在采集和播放声音文件时所使用数字声音信号的二进制位数。采集卡的位客观地反映了数字声音信号对输入声音信号描述的准确程度。例如，同一段音频信息，使用8bit描述单个采样信息，那么采样量化的范围就是0~255,如果使用16bit表示单个采样值,那么相应的采样量化的范围为0~64k。与8位采样位数相比，16位采样的动态范围的宽度更小，动态范围更宽广，声音的被记录的更加精细。一般CD使用的采样位数为16位。</p>
<p>16位二进制数的最小值是0000000000000000，最大值是1111111111111111，对应的十进制数就是0和65535，也就是最大和最小值之间的差值是65535，也就是说，它量化的模拟量的动态范围可以差65535，也就是96.32分贝（20 * lg65535）），所以，量化精度只和动态范围有关，和频率响应没关系。动态范围定在96分贝也是有道理的，人耳的无痛苦极限声压是90分贝，96分贝的动态范围在普通应用中足够使用，所以96分贝动态范围内的模拟波，经量化后，不会产生削波失真的。</p>
<blockquote>
<p>所谓分贝是指两个相同的物理量（例A1和A0）之比取以10为底的对数并乘以10（或20）。N = 10lg(A1/A0) 分贝符号为”dB”，它是无量纲的。式中A0是基准量（或参考量），A是被量度量。被量度量和基准量之比取对数，这对数值称为被量度量的”级”。亦即用对数标度时，所得到的是比值，它代表被量度量比基准量高出多少”级”。</p>
</blockquote>
<h3 id="位速-比特率-码率"><a href="#位速-比特率-码率" class="headerlink" title="位速/比特率/码率"></a>位速/比特率/码率</h3><p>位速/比特率/码率描述的都是一个东西，是指在一个数据流中每秒钟能通过的信息量。我们可能看到过音频文件用 “128–Kbps MP3” 或 “64–Kbps WMA” 进行描述的情形。Kbps 表示 “每秒千位数”，因此数值越大表示数据越多：128–Kbps MP3 音频文件包含的数据量是 64–Kbps WMA 文件的两倍，并占用两倍的空间。（不过在这种情况下，这两种文件听起来没什么两样。原因是什么呢？有些文件格式比其他文件能够更有效地利用数据， 64–Kbps WMA 文件的音质与 128–Kbps MP3 的音质相同。）需要了解的重要一点是，位速越高，信息量越大，对这些信息进行解码的处理量就越大，文件需要占用的空间也就越多。</p>
<p>从码率的计算公式中可以清楚的看出码率和采样位数的关系:</p>
<p><code>码率=取样频率×量化精度×声道数</code></p>
<blockquote>
<p>一张CD,双声道,采样率44.1kHz，每个采样位数13bit，时长74分钟(4440秒)，则CD的容量为<code>13*2*44100*4440</code>约等于<code>640MB</code>。</p>
</blockquote>
<h3 id="VBR、ABR、CBR"><a href="#VBR、ABR、CBR" class="headerlink" title="VBR、ABR、CBR"></a>VBR、ABR、CBR</h3><p>VBR(Variable Bitrate)动态比特率。也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率。这是新发展的算法，他们将一首歌的复杂部分用高Bitrate编码，简单部分用低Bitrate编码。主意虽然不错，可惜新编码器的VBR算法很差，音质与CBR相去甚远。幸运的是， Lame完美地优化了VBR算法，使之成为MP3的最佳编码模式。这是以质量为前提兼顾文件大小的方式，推荐编码模式。</p>
<p>ABR(Average Bitrate)平均比特率，是VBR的一种插值参数。Lame针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR也被称为“Safe VBR”，它是在指定的平均Bitrate内，以每50帧(30帧约1秒)为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量。举例来说，当指定用192kbps ABR对一段wav文件进行编码时，Lame会将该文件的85%用192kbps固定编码，然后对剩余15%进行动态优化：复杂部分用高于192kbps 来编码、简单部分用低于192kbps来编码。与192kbps CBR相比，192kbps ABR在文件大小上相差不多，音质却提高不少。ABR编码在速度上是VBR编码的2到3倍，在128-256kbps范围内质量要好于CBR。可以做为 VBR和CBR的一种折衷选择。</p>
<p>CBR(Constant Bitrate)，常数比特率，指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，但音质却不会有明显的提高。</p>
<h3 id="PCM格式与LPCM格式"><a href="#PCM格式与LPCM格式" class="headerlink" title="PCM格式与LPCM格式"></a>PCM格式与LPCM格式</h3><p>PCM（脉冲编码调制）是一种将模拟语音信号变换为数字信号的编码方式。主要经过3个过程：抽样、量化和编码。抽样过程将连续时间模拟信号变为离散时间、连续幅度的抽样信号，量化过程将抽样信号变为离散时间、离散幅度的数字信号，编码过程将量化后的信号编码成为一个二进制码组输出。</p>
<p>量化分为线性量化和非线性量化。线性量化在整个量化范围内，量化间隔均相等，称为LPCM。非线性量化采用不等的量化间隔。量化间隔数由编码的二进制位数决定。例如，CD采用16bit线性量化，则量化间隔数L=65536。位数（n)越多，精度越高，信噪比<code>SNR=6.02n+1.76</code>(dB)也越高。但编码的二进制位数不是无限制的，需要根据所需的数据率确定。比如：CD可以达到的数据率为2×44.1×16=1411.2Kbit/s。</p>
<p>总而言之，LPCM格式中的音频数据是未压缩的线性量化后的音频数据。</p>
<blockquote>
<p>用iOS的官方文档中对几个关键词的解释：</p>
<ul>
<li>A sample is single numerical value for a single channel.</li>
<li>A frame is a collection of time-coincident samples. For instance, a stereo sound file has two samples per frame, one for the left channel and one for the right channel.</li>
<li>A packet is a collection of one or more contiguous frames. In linear PCM audio, a packet is always a single frame. In compressed formats, it is typically more. A packet defines the smallest meaningful set of frames for a given audio data format.</li>
</ul>
</blockquote>
<h3 id="压缩过的音频格式"><a href="#压缩过的音频格式" class="headerlink" title="压缩过的音频格式"></a>压缩过的音频格式</h3><p>在常见的音频格式对PCM原始帧进行封装时也是以frame帧为单位的，我们一般将压缩后的音频数据帧称为媒体帧，对应原始的PCM数据称为原始帧。每个媒体帧又分成head头，body数据体。在帧头中，会存储这个媒体帧中body部分的码率，采样率等解码必须的信息，因此每一个媒体帧都可以独立于文件存在和播放。在body中存储着一个或者多个媒体帧，这些媒体真是若干个PCM原始帧经过特定的压缩算法压缩得到的。通常情况下，我们将单位时间的媒体帧的个数称为帧率。</p>
<p>上文的采样率和帧率这两个概念都描述了音频媒体的“连续”性，二者的区别在于每个音频的媒体帧中会包含多个音频采样(多个PCM data)，如1个AAC帧中包含1024个采样。</p>
<blockquote>
<p>在学习音频/视频相关内容之前,首先需要弄清楚的的是音频的文件类型和音频格式是有本质区别的.封装类型比如.ogg,音频格式比如.mp3.(具体的区别可以百度)</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/28/popToViewController的坑/" itemprop="url">
                  popToViewController的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-28T14:59:58+08:00" content="2016-07-28">
              2016-07-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/28/popToViewController的坑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/28/popToViewController的坑/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用popViewController时候遇到了两个比较隐蔽的问题.因此,在以后的开发中需要自己注意.</p>
<h3 id="tips1"><a href="#tips1" class="headerlink" title="tips1"></a>tips1</h3><p>在调用popViewController时,使用GCD丢到main queue中去执行:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">	...</div><div class="line">   [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">NO</span>];</div><div class="line">	...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="tips2"><a href="#tips2" class="headerlink" title="tips2"></a>tips2</h3><p>在代码中可能连续多次调用<code>popViewControllerAnimated</code>地方,最好通过遍历<code>navigationController.viewControllers</code>找到具体要遍历到哪个再直接pop到目标<code>controller</code>.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="built_in">BOOL</span> findIt = <span class="literal">NO</span>;</div><div class="line">    <span class="built_in">UIViewController</span> *targetVC = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIViewController</span> *subVC <span class="keyword">in</span> <span class="keyword">self</span>.navigationController.viewControllers) &#123;</div><div class="line">        <span class="keyword">if</span> (findIt) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (subVC == xxx) &#123;</div><div class="line">            findIt = <span class="literal">YES</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            targetVC = subVC;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	[<span class="keyword">self</span>.navigationController popToViewController:targetVC animated:<span class="literal">NO</span>];</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/26/RunLoop总结/" itemprop="url">
                  RunLoop学习总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-26T21:17:16+08:00" content="2016-07-26">
              2016-07-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/26/RunLoop总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/26/RunLoop总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过前面几篇文章可以知道RunLoop实际上是一个事件处理的循环.只要一个线程启动了RunLoop,在它没有收到事件时候,它就会使得线程休眠,如果有事件,就调用相应的事件处理函数.</p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>RunLoop与线程是一一对应的.每个新建的线程(MovedainThread除外,主线程会默认启动)在默认状态下,它的RunLoop是没有开启的,必须手动调用<code>CurrentRunLoop</code>等方法才会开启RunLoop.通常iOS开发中,接触到的API分别是Cocoa的NSRunLoop和CoreFoundation的CFRunLoop.</p>
<h3 id="RunLoop的组成"><a href="#RunLoop的组成" class="headerlink" title="RunLoop的组成"></a>RunLoop的组成</h3><p>RunLoop每次只能运行在一个mode中,它与mode是一对多的关系.RunLoopMode中包括不同类型的事件源,主要分成两大类:TimerSource, 各种异步输入InputSource.与此同时,RunLoop会在不同的声明周期给外界发送通知,告知观察者自己的状态.因此可以注册RunLoopObserver来观察RunLoop的状态.他们之间的关系如下:</p>
<ul>
<li>一个runLoop包含多个Mode,每个Mode内有多个个Source/Timer/Observer(底层会在RunLoopMode中用Array存储)</li>
<li>每次启动RunLoop,需要指定一个Mode(<code>CFRunLoopRunSpecific</code>函数),如果需要切换Mode,只能退出RunLoop，再重新调用<code>CFRunLoopRunSpecific</code>,重新指定Mode</li>
<li>Source/Timer/Observer统称为mode item,每个item可以同时加入多个mode,但一个item被重复加入同一个mode无效</li>
<li>如果一个mode中一个item都没有,RunLoop就会立即退出(AFNetworking2.x)</li>
</ul>
<h4 id="1-RunLoopMode"><a href="#1-RunLoopMode" class="headerlink" title="1. RunLoopMode"></a>1. RunLoopMode</h4><p>RunLoop会运行在某个特定的mode下,称为RunLoopMode,具体mode可以使用系统的NSDefaultMode或者NSTrackingMode,也可以自己定义mode.如果想让事件在任何一个mode中处理,可以把事件源加入到CommonMode中.</p>
<h4 id="2-TimerSource"><a href="#2-TimerSource" class="headerlink" title="2. TimerSource"></a>2. TimerSource</h4><p>TimerSource在Cocoa框架中,一般是NSTimer.在使用它时,它会向RunLoop发送消息,RunLoop会根据Timer的类型去单次或者多次执行回调函数.在开始启动Timer时候,需要手动设定具体运行在哪一个RunLoopMode,默认情况下会运行在NSDefaultMode.</p>
<p>通过RunLoop的源码发现,TimerSource的触发实际是通过Source1(MachPort)唤醒RunLoop,然后调用回调方法的.</p>
<h4 id="3-异步输入源InputSource"><a href="#3-异步输入源InputSource" class="headerlink" title="3. 异步输入源InputSource"></a>3. 异步输入源InputSource</h4><p>异步事件其实会包括的类型:</p>
<ul>
<li>source0: 非port事件,可以手动触发(内部只有一个callback函数指针)</li>
<li>source1: 基于MachPort的Source事件,大多是内核发出的,需要调用<code>mach_msg</code>方法</li>
</ul>
<h4 id="4-NSObject的selector源"><a href="#4-NSObject的selector源" class="headerlink" title="4. NSObject的selector源"></a>4. NSObject的selector源</h4><p>由NSObject 的 performSelector:wait:…等产生,下文会细讲.</p>
<h4 id="5-RunLoopObserver"><a href="#5-RunLoopObserver" class="headerlink" title="5. RunLoopObserver"></a>5. RunLoopObserver</h4><p>RunLoop的事件源中,Timer是同步事件,另外的是异步事件Source0,Source1,selector. 而RunLoopObserver可以让你在某个特定的时期处理一些事情,比如在RunLoop马上进入休眠状态时,或者在刚刚被唤醒时等等.</p>
<p>具体的RunLoop可以被观察的状态有:</p>
<ul>
<li>RunLoop进入时候(kCFRunLoopEntry)</li>
<li>RunLoop将要处理Timer时(kCFRunLoopBeforeTimers)</li>
<li>RunLoop将要处理Source0时(kCFRunLoopBeforeSources)</li>
<li>RunLoop将要进入睡眠的时候(kCFRunLoopBeforeWaiting)</li>
<li>RunLoop将要被唤醒的时(kCFRunLoopAfterWaiting)</li>
<li>RunLoop停止的时候(kCFRunLoopExit)</li>
</ul>
<p>你可以在RunLoop中观察一个或者多个状态.观察者也可以设置是否只观察一次或者重复多次观察,如果只观察一次,那么调用回调函数以后,观察者就自动被移除了.</p>
<h3 id="RunLoop具体循环逻辑"><a href="#RunLoop具体循环逻辑" class="headerlink" title="RunLoop具体循环逻辑"></a>RunLoop具体循环逻辑</h3><p>RunLoop源码中关键的函数有以下几个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRunSpecific(xxxx)//入口&amp;出口</div><div class="line">CFRunLoopRun(xxxx)//循环</div></pre></td></tr></table></figure>
<p>具体的执行过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">1 通知观察者runLoop已经启动(DoObserver)</div><div class="line">2 记录RunLoop启动事件,并设定RunLoop运行的超时条件</div><div class="line"></div><div class="line">**** RunLoop正式进入循环 *****</div><div class="line"></div><div class="line">3 通知观察者任何即将要开始的定时器(DoObserver)</div><div class="line">4 通知观察着任何即将启动的非基于端口的源(DoObserver)</div><div class="line">5 调用RunLoopMode的blocks链中的block方法(DoBlocks)</div><div class="line">6 启动任何准备好的非基于端口的source0源(DoSource0)</div><div class="line">7 调用RunLoopMode的blocks链中的block方法(DoBlocks)</div><div class="line">8 检查MachPort端口是否有消息要处理，如果有立即进入步骤12</div><div class="line">9 如果没有消息处理,通知观察者线程进入休眠(DoObserver)</div><div class="line"></div><div class="line">**** RunLoop休眠: zzz...****</div><div class="line"></div><div class="line">10 将线程至于休眠直到任意下面的事件发生(调用`mach_msg`使RunLoop休眠)</div><div class="line">	A.某一时间到达基于端口的源</div><div class="line">	B.定时器启动</div><div class="line">	C.runLoop设置的时间已经超过</div><div class="line">	D.runLoop被显示唤醒</div><div class="line">11 通知观察者线程将被唤醒(DoObserver)</div><div class="line">12 处理未处理的事件(有dispatchPort显示是哪个port的事件需要处理)</div><div class="line">	A.如果livePort为NULL,啥都不做(会跳出循环)</div><div class="line">	B.如果livePort是wakeUpPort,说明RunLoop运行超时(会跳出循环)</div><div class="line">	C.如果livePort是timerPort,说明timerSource启动(DoTimers),进入步骤3</div><div class="line">	D.如果livePort是dispatchPort,说明系统的libDispatch向主线程送消息,</div><div class="line">	  会调dispatch_async(dispatch_get_main_queue(),block)</div><div class="line">	E.如果livePort是其他port,通过mach_msg取出回调,处理事件(DoSource1),</div><div class="line">	  进入步骤3</div><div class="line">	</div><div class="line">**** RunLoop退出循环 ****</div><div class="line"></div><div class="line">13 通知观察者runLoop结束</div></pre></td></tr></table></figure>
<p>从RunLoop的底层源码可以看出,RunLoop中的各种DoXXXX函数与最终的callout系统调用关系如下:</p>
<ul>
<li>DoObserver<br><code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__()</code></li>
<li>DoBlocks<br><code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__()</code></li>
<li>DoSource0 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__()</code></li>
<li>DoTimers <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__()</code></li>
<li>dispatchPort <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code></li>
<li>DoSource1 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__()</code></li>
</ul>
<blockquote>
<p>注意,以上callout调用,对于传入RunLoopMode中的Timers,Source0s,Blocks都是数组,因此对数组内的每个满足条件的成员都会进行callout调用,而source1和dispatchPort由于唤醒时每次只能执行一个.</p>
<p>repeat Timers执行的时间不一定是完全准确的,如果错过某次执行,只能等到下次RunLoop循环时候再执行了</p>
</blockquote>
<h4 id="何时使用RunLoop"><a href="#何时使用RunLoop" class="headerlink" title="何时使用RunLoop"></a>何时使用RunLoop</h4><p>自己配置并启动它，你不需要再任何情况下都去启动一个线程的runLoop。runLoop在你<br>要和线程有更多的交互时才需要，比如以下情况：</p>
<ul>
<li>使用端口或者自定义输入源来和其他线程通信；</li>
<li>使用线程的NSTimer (可以用dispatch_timer代替)</li>
<li>Cocoa中使用任何performSelector</li>
<li>让线程周期性干活(AFNetworking2.x)</li>
</ul>
<h3 id="CFRunLoop相关内容"><a href="#CFRunLoop相关内容" class="headerlink" title="CFRunLoop相关内容"></a>CFRunLoop相关内容</h3><h4 id="CoreFoundation中RunLoop的接口"><a href="#CoreFoundation中RunLoop的接口" class="headerlink" title="CoreFoundation中RunLoop的接口"></a>CoreFoundation中RunLoop的接口</h4><p>一般使用的是CoreFoundation中的CFRunLoop,因此这里主要总结CFRunLoop的对外接口.RunLoop中对外主要有以下几个接口类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef (并未对外暴露)</li>
<li>CFRunLoopSourceRef: 异步的source0和source1事件源<ul>
<li>source0: 结构体中只有perform回调函数,它并不能主动触发事件,使用时,需要手动触发(<code>CFRunLoopSourceSignal()</code>).CFRunLoopSourceSignal将这个source标记为待处理，后调用CFRunLoopWakeUp来唤醒runLoop，让其处理这个事件(也就是source0无法唤醒RunLoop)</li>
<li>source1: 结构体中有mach_port和invoke回调函数,通常是内核和其他进程给该RunLoop发送的消息,从源码可以看出source1,是可以自动唤醒RunLoop的,因为它是通过port方式发送事件的.</li>
</ul>
</li>
<li>CFRunLoopTimerRef: 同步的TimerSource, 在Cocoa中是NSTimer.它的底层结构体中包含触发时间和回调，当其加入到runLoop中是，runLoop会注册对应的时间点，当时<br>间点到时,RunLoop会收到wakeUpPort(RunLoop的一个属性)source1类型的消息,将唤醒以执行Timer的回调；</li>
<li>CFRunLoopObserverRef: 注册观察者时候可以添加一个回调函数,当RunLoop的状态变化时会通知注册的观察者,注册的回调函数在此时调用</li>
</ul>
<blockquote>
<p>具体的demo可以参考:<br><a href="https://github.com/brownfeng/RunLoopDemo" target="_blank" rel="external">https://github.com/brownfeng/RunLoopDemo</a></p>
<h4 id="RunLoop底层结构体"><a href="#RunLoop底层结构体" class="headerlink" title="RunLoop底层结构体"></a>RunLoop底层结构体</h4></blockquote>
<p>CFRunLoop的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFMutableSetRef _commonModes;     </div><div class="line">    CFMutableSetRef _commonModeItems; </div><div class="line">    CFRunLoopModeRef _currentMode;    </div><div class="line">    CFMutableSetRef _modes;           </div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>CFRunLoopMode的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            </div><div class="line">    CFMutableSetRef _sources0;    </div><div class="line">    CFMutableSetRef _sources1;    </div><div class="line">    CFMutableArrayRef _observers; </div><div class="line">    CFMutableArrayRef _timers;    </div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，CFRunLoop对外暴露的管理Mode的接口有两个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddCommonMode</div><div class="line">CFRunLoopRunInMode</div></pre></td></tr></table></figure>
<p>Mode暴露的管理mode item的接口有下面几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddSource</div><div class="line">CFRunLoopAddObserver</div><div class="line">CFRunLoopAddTimer</div><div class="line">CFRunLoopRemoveSource</div><div class="line">CFRunLoopRemoveObserver</div><div class="line">CFRunLoopRemoveTimer</div></pre></td></tr></table></figure>
<h3 id="Cocoa框架中RunLoop相关的内容"><a href="#Cocoa框架中RunLoop相关的内容" class="headerlink" title="Cocoa框架中RunLoop相关的内容"></a>Cocoa框架中RunLoop相关的内容</h3><h4 id="1-AutoReleasePool"><a href="#1-AutoReleasePool" class="headerlink" title="1 AutoReleasePool"></a>1 AutoReleasePool</h4><p>AutoReleasePool是Apple中清理临时变量,释放内容的机制,在app的main函数中,所有的内容都是包裹在一个AutoReleasePool中的.这个过程中,Apple在RunLoop中注册三个RunLoopObserver:</p>
<ul>
<li>第一个RunLoopObserver关注kCFRunLoopEntry状态,callback函数中会自动创建autoReleasePool,并且observer优先级最高(RunLoop第一个调用它的回调),保证应用启动后所有的操作都在autoreleasePool中运行.</li>
<li>第二个RunLoopObserver关注kCFRunLoopBeforeWaiting状态,在此时autoreleasePool会释放旧的池,并创建一个新的autoreleasePool.</li>
<li>第三个RunLoopObserver关注kCFRunLoopExit状态,此时释放autoreleasePool,并且保证observer的优先级最低,即在所有其他的observers都执行完以后才执行autorelease相关的observer的callback函数.</li>
</ul>
<blockquote>
<p>深入学习可以参考:<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p>
</blockquote>
<h4 id="2-iOS事件响应"><a href="#2-iOS事件响应" class="headerlink" title="2 iOS事件响应"></a>2 iOS事件响应</h4><p>RunLoop解释了为何iOS应用能够接受到屏幕触摸等事件.Apple在iOS app启动时候在main RunLoop中注册一个Source1事件,是基于Mach Port(进程间通信)的系统层面的进程.</p>
<p>当一个触摸事件发生以后,IOKit会生成一个IOHIDEvent事件,并由系统层面的SpringBoard接受按键(锁屏/静音),触摸,加速,接近传感器等几种Event,然后通过进程间通信的mach port发送给App的main RunLoop.然后在DoSource1中,source1的回调会触发,内部会调用系统<code>_UIApplicationHandleEventQueue()</code>进行事件分发.</p>
<p><code>_UIApplicationHandleEventQueue()</code>方法会把IOHIDEvent处理,并包装成常见的UIEvent事件进行处理或分发,其中包括识别UIGesture/处理屏幕旋转/发送给UIWindow等.通常事件比如UIButton点击,touchesBegin/Move/End/Cancel等事件都是在这个Source1回调中完成.</p>
<h4 id="3-手势识别GestureRecognizer"><a href="#3-手势识别GestureRecognizer" class="headerlink" title="3 手势识别GestureRecognizer"></a>3 手势识别GestureRecognizer</h4><p>在上面的事件响应中,回调方法<code>_UIApplicationHandleEventQueue()</code>识别了一个手势以后,首先会调用Cancel将当前的touchesBegin/Move/End系列的回调打断.随后系统会将UIGestureRecognizer标记为等待处理.</p>
<p>然后苹果会在RunLoop中注册一个Observer观察kCFRunLoopBeforeWaiting(睡眠前).这个观察者的回调函数是<code>_UIGestureRecognizerUpdateObserver()</code>,它会获取刚才所有被标记为等待处理等的GestureRecognizer,并且执行GestureRecognizer的回调.</p>
<h4 id="4-界面更新-UI-update"><a href="#4-界面更新-UI-update" class="headerlink" title="4 界面更新(UI update)"></a>4 界面更新(UI update)</h4><p>在App改变UI时,例如修改view的Frame,更新UIView/CALayer的层次,或者手动调用UIView/CALayer的setNeedsLayout/setNeedsDisplay方法以后,这个UIView/CALayer就被标记为等待处理,并且提交到一个全局容器.</p>
<p>然后苹果在RunLoop中注册一个Observer观察kCFRunLoopBeforeWaiting和kCFRunLoopExit状态.在状态触发DoObserver的callback中会调用函数<code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>.这个函数中会遍历所有的等待处理的UIView/CALayer,执行绘制和调整,更新UI界面.</p>
<p>这个函数的调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">    QuartzCore:CA::Transaction::observer_callback://DoObserver</div><div class="line">        CA::Transaction::commit();//提交到全局容器</div><div class="line">            CA::Context::commit_transaction();</div><div class="line">                CA::Layer::layout_and_display_if_needed();</div><div class="line">                    CA::Layer::layout_if_needed();</div><div class="line">                        [CALayer layoutSublayers];</div><div class="line">                            [UIView layoutSubviews];</div><div class="line">                    CA::Layer::display_if_needed();</div><div class="line">                        [CALayer display];</div><div class="line">                            [UIView drawRect];</div></pre></td></tr></table></figure>
<h4 id="5-NSTimer定时器"><a href="#5-NSTimer定时器" class="headerlink" title="5 NSTimer定时器"></a>5 NSTimer定时器</h4><p>NSTimer的CF层是CFRunLoopTimerRef,它们可以toll-free bridged.当使用<code>CFRunLoopAddTimer()</code>将NSTimer&amp;CFRunLoopTimerRef注册到RunLoop中以后,RunLoop会为它重复的时间点注册好事件(有一定的时间容忍度,触发的时间误差).如果中间某次触发被错过,那么这次触发时间点的回调也会被跳过去. 实际中NSTimer的触发是通过source1触发的,如果timer被触发会将RunLoop的有一个Mach Port-<code>timePort</code>-发消息,然后会唤醒RunLoop,调用DoTimers.可以参考上面的RunLoop运行流程.</p>
<blockquote>
<p>CADisplayLink 是一个和屏幕刷新一致的定时器,如果两次屏幕刷新时候在执行一个长时间任务,那其中就会有一帧被跳过,造成界面卡顿.Facebook的AsyncDisplayLink使用RunLoop来解决丢帧的问题.</p>
<p>还有一个GCD的定时器<code>dispatch_timer</code>,RunLoop的超时机制也是使用<code>dispatch_timer</code>.</p>
</blockquote>
<h4 id="6-部分PerformSelector事件源"><a href="#6-部分PerformSelector事件源" class="headerlink" title="6 部分PerformSelector事件源"></a>6 部分PerformSelector事件源</h4><p>NSObject的部分与时间相关的PerformSelector方法与RunLoop密切相关.当调用NSObject的performSelector:afterDelay以后,实际内部会创建一个Timer并添加RunLoopMode中,等待Timer触发,然后调用DoTimers,其中包含的回调方法就是selector.因此如果当前线程没有开启RunLoop,这个方法无效.类似的NSObject的performSelector:onThread:也是类似,需要线程开启RunLoop.具体涉及到的perform方法包括:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- performSelector:afterDelay:</div><div class="line">– performSelector:withObject:afterDelay:</div><div class="line">– performSelectorOnMainThread:withObject:waitUntilDone:</div><div class="line">– performSelectorOnMainThread:withObject:waitUntilDone:modes:</div><div class="line">– performSelector:onThread:withObject:waitUntilDone:modes:</div><div class="line">- performSelector:onThread:withObject:waitUntilDone:</div></pre></td></tr></table></figure>
<h4 id="7-GCD与RunLoop"><a href="#7-GCD与RunLoop" class="headerlink" title="7 GCD与RunLoop"></a>7 GCD与RunLoop</h4><p>GCD的中部分接口使用了RunLoop,提交到mainQueue的blocks.当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时,libDispatch(系统的某个进程)会向app的进程的main runloop的dispatchPort(是一个mach port)发送消息.此时RunLoop如果在休眠状态,会被唤醒,并从dispatch port中取出消息,并在会在回调方法<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code>中执行这个block.</p>
<blockquote>
<p>libDispatch分发到main queue的block才会与RunLoop有关,分发到其他的子线程的内容,还是又libDispatch处理.</p>
<p>RunLoop的运行超时是由GCD的dispatch_timer控制的.</p>
</blockquote>
<h4 id="8-关于网络请求"><a href="#8-关于网络请求" class="headerlink" title="8 关于网络请求"></a>8 关于网络请求</h4><p>关于网络请求的接口，主要有以下几层:</p>
<ul>
<li>CFSocket:是最底层的接口，只负责socket的通信</li>
<li>CFNetwork:是基于CFSocket等接口的上层封装,ASIHttpRequest工作在这层</li>
<li>NSURLConnection:是基于CFNetwork的更高层的封装，提供面向对象的接口，<br>AFNetworking2.x工作于这一层</li>
<li>NSURLSession:是ios7中新增的接口,表面上和NSURLConnection并列,但底层<br>仍然用到NSURLConnection的部分功能,AFNetworking3.x和Alamofire在这层</li>
</ul>
<p>因此,现在使用的大多网络库都与CFSocket,CFNetwork层相关.</p>
<p>通常使用NSURLConnection时,你会传入一个Delegate,当调用[connection start]后，这个Delegate就会不停收到事件回调。实际上,start 这个函数的内部会<br>会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动<br>触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookie<br>Storage 是处理各种 Cookie 的。</p>
<blockquote>
<p>NSURLConnection的工作过程可以参考:<br><a href="http://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/#base</a></p>
</blockquote>
<h3 id="RunLoop的应用举例"><a href="#RunLoop的应用举例" class="headerlink" title="RunLoop的应用举例"></a>RunLoop的应用举例</h3><h4 id="1-AFNetworking2-x"><a href="#1-AFNetworking2-x" class="headerlink" title="1 AFNetworking2.x"></a>1 AFNetworking2.x</h4><p>使用NSURLConnection时候,需要在后台自定义线程中接受Delegate回调.AFNetworking创建一个自定义线程,然后在其中添加一个Mach Port,然后启动RunLoop(前面提到过,如果RunLoop中没有source/timer/observer会立即退出).在以后线程以后通过NSObject的<code>performSelector:onThread:withObject:waitUnitlDone:modes:</code>方法,将<code>[self.connection scheduleInRunLoop:runLoop forMode:runLoopMode]</code>.</p>
<blockquote>
<p>可以参考:<br><a href="https://github.com/brownfeng/SourceSet/tree/master/AFNetworking2.x" target="_blank" rel="external">https://github.com/brownfeng/SourceSet/tree/master/AFNetworking2.x</a></p>
</blockquote>
<h4 id="2-AsyncDisplayKit"><a href="#2-AsyncDisplayKit" class="headerlink" title="2 AsyncDisplayKit"></a>2 AsyncDisplayKit</h4><p>AsyncDisplayKit是Facebook推出的用于保持界面流畅性的框架,其原理大致如下：</p>
<p>UI线程中一旦出现繁重的任务就会导致界面卡顿,这类任务通常分为3类:排版,绘制,UI对象操作。通过各种方法将前两种任务丢到后台运行,最后一类操作只能在主线程中执行,因此,ASDK仿照QuartzCore/UIKit框架的模式,实现了一套类似的界面更新的机制:即在主线程的RunLoop中添加一个 Observer,监听kCFRunLoopBeforeWaiting和 kCFRunLoopExit事件,在收到回调时,遍历所有之前放入队列的待处理的任务,然后一一执行。</p>
<h4 id="3-NSTimer在TrackingMode运行"><a href="#3-NSTimer在TrackingMode运行" class="headerlink" title="3 NSTimer在TrackingMode运行"></a>3 NSTimer在TrackingMode运行</h4><h4 id="4-TableView延迟加载图片"><a href="#4-TableView延迟加载图片" class="headerlink" title="4 TableView延迟加载图片"></a>4 TableView延迟加载图片</h4><h4 id="5-RunLoop解决大图加载的问题"><a href="#5-RunLoop解决大图加载的问题" class="headerlink" title="5 RunLoop解决大图加载的问题"></a>5 RunLoop解决大图加载的问题</h4><h4 id="6-RunLoop监控App卡顿"><a href="#6-RunLoop监控App卡顿" class="headerlink" title="6 RunLoop监控App卡顿"></a>6 RunLoop监控App卡顿</h4><blockquote>
<p>可以参考文章:</p>
<p><a href="http://www.jianshu.com/p/929d855c5a5a" target="_blank" rel="external">http://www.jianshu.com/p/929d855c5a5a</a><br><a href="http://www.jianshu.com/p/924cb2b218f5" target="_blank" rel="external">http://www.jianshu.com/p/924cb2b218f5</a></p>
</blockquote>
<h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/</a></p>
<p><a href="http://yun.baidu.com/share/link?shareid=2268593032&amp;uk=2885973690" target="_blank" rel="external">http://yun.baidu.com/share/link?shareid=2268593032&amp;uk=2885973690</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="brownfeng" />
          <p class="site-author-name" itemprop="name">brownfeng</p>
          <p class="site-description motion-element" itemprop="description">行走路上,记录风景~</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/brownfeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1980801167" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brownfeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"brownfeng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
